import os
import requests
import json
import time
from flask import Flask, request, jsonify
import google.generativeai as genai
import grpc

# --- gRPC Imports ---
# The gRPC stubs are generated by the Dockerfile
import demo_pb2
import demo_pb2_grpc

# --- Observability ---
from opentelemetry import metrics
from opentelemetry.sdk.metrics import MeterProvider
from opentelemetry.sdk.metrics.export import PeriodicExportingMetricReader, ConsoleMetricExporter
from opentelemetry.sdk.resources import Resource

# For a real-world application, you would export to a system like Prometheus or Cloud Monitoring
# For this demo, we're exporting to the console.
resource = Resource(attributes={"service.name": "recommendation-agent"})
reader = PeriodicExportingMetricReader(ConsoleMetricExporter())
provider = MeterProvider(resource=resource, metric_readers=[reader])
metrics.set_meter_provider(provider)

meter = metrics.get_meter("recommendation.agent")
llm_latency_metric = meter.create_histogram(
    "llm.latency",
    unit="ms",
    description="The latency of the call to the generative AI model"
)


app = Flask(__name__)

# --- Configuration ---
CATALOG_READER_URL = os.environ.get("CATALOG_READER_URL")
if not CATALOG_READER_URL:
    raise RuntimeError("CATALOG_READER_URL environment variable not set.")

CART_SERVICE_ADDR = os.environ.get('CART_SERVICE_ADDR', 'cartservice:7070')

try:
    GOOGLE_API_KEY = os.environ["GOOGLE_API_KEY"]
    genai.configure(api_key=GOOGLE_API_KEY)
except KeyError:
    raise RuntimeError("GOOGLE_API_KEY environment variable not set.")


# --- Tool Definition: Functions to interact with the catalog-reader ---

def search_products(query: str) -> str:
    """
    Searches for products based on a query string.
    Args:
        query: The search term (e.g., "black shoes", "kitchenware").
    Returns:
        A JSON string representing a list of products found.
    """
    print(f"TOOL: Searching for products with query: {query}")
    try:
        response = requests.post(f"{CATALOG_READER_URL}/products:search", json={"query": query})
        response.raise_for_status()
        return json.dumps(response.json())
    except requests.exceptions.RequestException as e:
        return f"Error searching for products: {e}"

# Note: The get_product_details tool is available but the prompt will guide the model
# to primarily use the search_products tool for efficiency.
def get_product_details(product_id: str) -> str:
    """
    Gets the detailed information for a single product by its ID.
    Args:
        product_id: The unique identifier of the product.
    Returns:
        A JSON string representing the product's details.
    """
    print(f"TOOL: Getting details for product ID: {product_id}")
    try:
        response = requests.get(f"{CATALOG_READER_URL}/products/{product_id}")
        response.raise_for_status()
        return json.dumps(response.json())
    except requests.exceptions.RequestException as e:
        return f"Error getting product details: {e}"

def add_item_to_cart(product_id: str, quantity: int) -> str:
    """
    Adds a specified quantity of a product to the user's shopping cart.
    Args:
        product_id: The ID (SKU) of the product to add.
        quantity: The number of items to add.
    Returns:
        A confirmation message string.
    """
    # This tool is coupled with the Flask request context to get the user ID.
    # This is a simplification for the demo.
    user_id = request.json.get('userId', 'anonymous')
    print(f"TOOL: Adding {quantity} of product {product_id} to cart for user {user_id}")

    try:
        # Create a gRPC channel and stub for the cart service
        channel = grpc.insecure_channel(CART_SERVICE_ADDR)
        stub = demo_pb2_grpc.CartServiceStub(channel)

        # Create the request message
        request_message = demo_pb2.AddItemRequest(
            user_id=user_id,
            item=demo_pb2.CartItem(product_id=product_id, quantity=quantity)
        )

        # Make the gRPC call
        stub.AddItem(request_message)
        print(f"TOOL: Successfully added item to cart.")
        return f"Successfully added {quantity} of product {product_id} to the cart."
    except grpc.RpcError as e:
        print(f"TOOL ERROR: gRPC call to cartservice failed: {e.details()}")
        return f"Error: Could not add item to cart. gRPC error: {e.details()}"
    except Exception as e:
        print(f"TOOL ERROR: An unexpected error occurred: {e}")
        return f"Error: An unexpected error occurred while adding item to cart."


# --- Generative AI Model Setup ---

SYSTEM_PROMPT = """
You are an expert shopping assistant for the "Online Boutique".
You have two primary jobs: finding products and adding them to the user's cart.
You must respond with a valid JSON object and nothing else.

# Finding Products
- When the user asks to find a product, your goal is to call the `search_products` tool and then return a JSON object with "suggestions" and "compare" keys.

## Instructions for Finding Products:
1.  Call the `search_products` tool with a relevant search term from the user's query.
2.  The tool will return a JSON string containing a list of products. You need to process this list.
3.  Your final response MUST be a single JSON object with two top-level keys: "suggestions" and "compare".
4.  **The "suggestions" key**:
    *   The value must be a list of JSON objects, where each object represents a product you recommend.
    *   For each product, create a new JSON object with the following keys: `sku`, `name`, `price`, `why`.
    *   The `sku` is the `id` from the tool's response. The `name` is the `name`, and the `price` must be a number from the `units` field of the `priceUsd` object.
    *   The `why` field is the most important. It must be a short, helpful, and friendly sentence explaining why the product is a good match.
5.  **The "compare" key**:
    *   The value must be a JSON object used to generate a comparison table.
    *   It must have two keys: "columns" and "rows".
    *   `columns` must be a list of strings: ["Name", "Price (USD)", "Categories"].
    *   `rows` must be a list of lists. Each inner list represents a recommended product and its values must correspond to the order of the columns (name, price, categories as a string).

# Cart Management
- When the user asks to add an item to their cart, your goal is to call the `add_item_to_cart` tool.

## Instructions for Cart Management:
1.  If the user asks to add an item to the cart, you MUST use the `add_item_to_cart` tool.
2.  You will need the `product_id` (which is the `sku` from a previous suggestion) and the `quantity`. If the quantity is not specified, assume it is 1.
3.  After calling the tool, it will return a confirmation message.
4.  Your final response in this case MUST be a simple JSON object with a single key, "message". The value of this key should be the confirmation message from the tool.

## Example of Finding Products:
IF the user query is "I need some comfortable shoes"
AND the tool returns a list of shoes,
THEN your final response MUST be in the `{"suggestions": [...], "compare": {...}}` format.

## Example of Adding to Cart:
IF the user query is "Okay, add two of the running shoes to my cart"
AND the SKU for "Running Shoes" is "OLJCESPC7Z"
AND you call `add_item_to_cart(product_id="OLJCESPC7Z", quantity=2)`
AND the tool returns "Successfully added 2 of product OLJCESPC7Z to the cart."
THEN your final response to the user MUST be this exact JSON object:
```json
{
  "message": "Successfully added 2 of product OLJCESPC7Z to the cart."
}
```
Now, begin.
"""

model = genai.GenerativeModel(
    model_name='gemini-1.5-pro-latest',
    tools=[search_products, get_product_details, add_item_to_cart],
    system_instruction=SYSTEM_PROMPT,
    generation_config={"response_mime_type": "application/json"}
)

# --- Flask API Endpoint ---

@app.route('/recommend', methods=['POST'])
def recommend():
    data = request.get_json()
    if not data or 'query' not in data:
        return jsonify({"error": "Request body must be JSON with a 'query' field."}), 400

    user_query = data['query']
    print(f"API: Received query: {user_query}")

    chat = model.start_chat(enable_automatic_function_calling=True)

    try:
        start_time = time.time()
        response = chat.send_message(user_query)
        end_time = time.time()

        # Record the latency
        latency_ms = (end_time - start_time) * 1000
        llm_latency_metric.record(latency_ms)
        print(f"METRIC: LLM latency: {latency_ms:.2f} ms")


        # With JSON mode enabled, the response text is a guaranteed JSON string.
        final_json_response = json.loads(response.text)
        return jsonify(final_json_response)

    except (json.JSONDecodeError, Exception) as e:
        # Check if response object exists before trying to access its text attribute
        raw_response_text = "N/A"
        if 'response' in locals() and hasattr(response, 'text'):
            raw_response_text = response.text
        error_message = f"Failed to get a valid JSON response from the model. Error: {e}. Raw response: {raw_response_text}"
        print(f"API ERROR: {error_message}")
        return jsonify({"error": error_message}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080, debug=True)
