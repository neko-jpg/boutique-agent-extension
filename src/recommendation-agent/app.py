import os
import requests
import json
import time
from flask import Flask, request, jsonify
import google.generativeai as genai
import grpc

# --- gRPC Imports ---
# The gRPC stubs are generated by the Dockerfile into the 'genproto' directory
from genproto import demo_pb2
from genproto import demo_pb2_grpc

# --- Caching ---
from cachetools import LRUCache, cached

# --- Observability ---
from opentelemetry import metrics
from opentelemetry.sdk.metrics import MeterProvider
from opentelemetry.sdk.metrics.export import PeriodicExportingMetricReader, ConsoleMetricExporter
from opentelemetry.sdk.resources import Resource

# For a real-world application, you would export to a system like Prometheus or Cloud Monitoring
# For this demo, we're exporting to the console.
resource = Resource(attributes={"service.name": "recommendation-agent"})
reader = PeriodicExportingMetricReader(ConsoleMetricExporter())
provider = MeterProvider(resource=resource, metric_readers=[reader])
metrics.set_meter_provider(provider)

meter = metrics.get_meter("recommendation.agent")
llm_latency_metric = meter.create_histogram(
    "llm.latency",
    unit="ms",
    description="The latency of the call to the generative AI model"
)

# --- Cache Initialization ---
# Create an LRU cache with a maximum size of 100 entries
reco_cache = LRUCache(maxsize=100)


app = Flask(__name__)

# --- Configuration ---
CATALOG_READER_URL = os.environ.get("CATALOG_READER_URL")
if not CATALOG_READER_URL:
    raise RuntimeError("CATALOG_READER_URL environment variable not set.")

PROMO_AGENT_URL = os.environ.get("PROMO_AGENT_URL") # e.g. "http://promo-agent:8080"
CART_SERVICE_ADDR = os.environ.get('CART_SERVICE_ADDR', 'cartservice:7070')

try:
    GOOGLE_API_KEY = os.environ["GOOGLE_API_KEY"]
    genai.configure(api_key=GOOGLE_API_KEY)
except KeyError:
    raise RuntimeError("GOOGLE_API_KEY environment variable not set.")


# --- Tool Definition: Functions to interact with the catalog-reader ---

def search_products(query: str) -> str:
    """
    Searches for products based on a query string.
    Args:
        query: The search term (e.g., "black shoes", "kitchenware").
    Returns:
        A JSON string representing a list of products found.
    """
    print(f"TOOL: Searching for products with query: {query}")
    try:
        response = requests.post(f"{CATALOG_READER_URL}/products:search", json={"query": query})
        response.raise_for_status()
        return json.dumps(response.json())
    except requests.exceptions.RequestException as e:
        return f"Error searching for products: {e}"

# Note: The get_product_details tool is available but the prompt will guide the model
# to primarily use the search_products tool for efficiency.
def get_product_details(product_id: str) -> str:
    """
    Gets the detailed information for a single product by its ID.
    Args:
        product_id: The unique identifier of the product.
    Returns:
        A JSON string representing the product's details.
    """
    print(f"TOOL: Getting details for product ID: {product_id}")
    try:
        response = requests.get(f"{CATALOG_READER_URL}/products/{product_id}")
        response.raise_for_status()
        return json.dumps(response.json())
    except requests.exceptions.RequestException as e:
        return f"Error getting product details: {e}"

def add_item_to_cart(product_id: str, quantity: int) -> str:
    """
    Adds a specified quantity of a product to the user's shopping cart.
    Args:
        product_id: The ID (SKU) of the product to add.
        quantity: The number of items to add.
    Returns:
        A confirmation message string.
    """
    # This tool is coupled with the Flask request context to get the user ID.
    # This is a simplification for the demo.
    user_id = request.json.get('userId', 'anonymous')
    print(f"TOOL: Adding {quantity} of product {product_id} to cart for user {user_id}")

    try:
        # Create a gRPC channel and stub for the cart service
        channel = grpc.insecure_channel(CART_SERVICE_ADDR)
        stub = demo_pb2_grpc.CartServiceStub(channel)

        # Create the request message
        request_message = demo_pb2.AddItemRequest(
            user_id=user_id,
            item=demo_pb2.CartItem(product_id=product_id, quantity=quantity)
        )

        # Make the gRPC call
        stub.AddItem(request_message)
        print(f"TOOL: Successfully added item to cart.")
        return f"Successfully added {quantity} of product {product_id} to the cart."
    except grpc.RpcError as e:
        print(f"TOOL ERROR: gRPC call to cartservice failed: {e.details()}")
        return f"Error: Could not add item to cart. gRPC error: {e.details()}"
    except Exception as e:
        print(f"TOOL ERROR: An unexpected error occurred: {e}")
        return f"Error: An unexpected error occurred while adding item to cart."

def add_to_watchlist(product_id: str) -> str:
    """
    Adds a product to the user's price drop watchlist.
    Args:
        product_id: The ID (SKU) of the product to watch.
    Returns:
        A confirmation message string.
    """
    print(f"TOOL: Adding product {product_id} to watchlist.")
    if not PROMO_AGENT_URL:
        return "Error: The promo agent is not configured, so I cannot add items to the watchlist."

    try:
        response = requests.post(f"{PROMO_AGENT_URL}/watchlist", json={"product_id": product_id})
        response.raise_for_status()
        return f"Success! The product {product_id} has been added to your price drop watchlist."
    except requests.exceptions.RequestException as e:
        print(f"TOOL ERROR: Failed to connect to promo agent: {e}")
        return f"Error: Could not add item to watchlist. Failed to connect to the promo agent."


# --- Generative AI Model Setup ---

# Default Prompt (Variant A)
SYSTEM_PROMPT_A = """
You are an expert shopping assistant for the "Online Boutique".
You have three primary jobs: finding products, adding them to the cart, and adding them to a watchlist.
You must respond with a valid JSON object and nothing else.

# Finding Products
- When the user asks to find a product, your goal is to call the `search_products` tool and then return a JSON object with "suggestions" and "compare" keys.
- **After providing a good suggestion, you should proactively ask the user if they want to add an item to their cart OR to the price watchlist.**

## Instructions for Finding Products:
1.  Call `search_products` with a relevant search term.
2.  Process the returned list of products.
3.  Your final response MUST be a single JSON object with "suggestions" and "compare" keys.
4.  The `why` field in your suggestion is very important. It must be a short, helpful, and friendly sentence explaining why the product is a good match.
5.  After explaining the suggestions, ask a follow-up question like "Would you like to add any of these to your cart, or shall I add one to your price watchlist?"

# Cart Management
- When the user asks to add an item to their cart, your goal is to call the `add_item_to_cart` tool.
- The tool needs a `product_id` and a `quantity` (default to 1).
- After the tool call, your final response MUST be a simple JSON object: `{"message": "Confirmation message from the tool"}`.

# Watchlist Management
- When the user asks to watch an item's price, your goal is to call the `add_to_watchlist` tool.
- The tool needs a `product_id`.
- After the tool call, your final response MUST be a simple JSON object: `{"message": "Confirmation message from the tool"}`.
"""

# Enthusiastic Prompt (Variant B)
SYSTEM_PROMPT_B = """
You are an enthusiastic and persuasive shopping assistant for the "Online Boutique"!
Your goal is to help users find amazing products, add them to their cart, or add them to a price watchlist!
You must respond with a valid JSON object and nothing else.

# Finding Products
- When a user wants to find a product, call `search_products` and return a JSON with "suggestions" and "compare".
- **After presenting your awesome suggestions, you MUST proactively ask the user if they want to add an item to their cart or if you should add it to a price watchlist for them!**

## Instructions for Finding Products:
1.  Call `search_products` with a great search term.
2.  The `why` field is your chance to shine! Write a short, enthusiastic, and sales-oriented sentence to get the user excited. Use exclamation points!
3.  After explaining the suggestions, ask an exciting follow-up question like "Aren't these great? Let me know if you want to add one to your cart, or I can put it on your price watchlist for you!"

# Cart Management
- When the user wants to add an item to their cart, use the `add_item_to_cart` tool.
- It needs `product_id` and `quantity` (default 1).
- Your final response MUST be a simple JSON object: `{"message": "Confirmation message from the tool"}`.

# Watchlist Management
- When a user says to watch an item, use the `add_to_watchlist` tool.
- It needs the `product_id`.
- Your final response MUST be a simple JSON object: `{"message": "Confirmation message from the tool"}`.
"""

@cached(reco_cache)
def get_recommendation_from_model(user_query: str, variant: str) -> str:
    """
    Gets a recommendation from the Generative AI model.
    This function is cached based on its arguments (user_query, variant).
    """
    print(f"CACHE MISS: Calling Generative AI model for query: '{user_query}', variant: '{variant}'")
    # Select the prompt based on the variant
    if variant == 'B':
        prompt = SYSTEM_PROMPT_B
    else:
        prompt = SYSTEM_PROMPT_A

    # Initialize the model
    model = genai.GenerativeModel(
        model_name='gemini-1.5-pro-latest',
        tools=[search_products, get_product_details, add_item_to_cart, add_to_watchlist],
        system_instruction=prompt,
        generation_config={"response_mime_type": "application/json"}
    )
    chat = model.start_chat(enable_automatic_function_calling=True)

    start_time = time.time()
    response = chat.send_message(user_query)
    end_time = time.time()

    # Record the latency
    latency_ms = (end_time - start_time) * 1000
    llm_latency_metric.record(latency_ms)
    print(f"METRIC: LLM latency: {latency_ms:.2f} ms")

    return response.text


# --- Flask API Endpoint ---

@app.route('/recommend', methods=['POST'])
def recommend():
    data = request.get_json()
    if not data or 'query' not in data:
        return jsonify({"error": "Request body must be JSON with a 'query' field."}), 400

    user_query = data['query']
    variant = data.get('variant', 'A').upper()

    try:
        # Get the recommendation, potentially from the cache
        response_text = get_recommendation_from_model(user_query, variant)

        # The model is in JSON mode, but as a fallback, strip markdown and find the JSON object.
        response_text_cleaned = response_text.strip().replace("```json", "").replace("```", "")
        json_start = response_text_cleaned.find('{')
        json_end = response_text_cleaned.rfind('}') + 1

        if json_start == -1 or json_end == 0:
             raise json.JSONDecodeError("No JSON object found in response", response_text_cleaned, 0)

        json_str = response_text_cleaned[json_start:json_end]
        final_json_response = json.loads(json_str)
        return jsonify(final_json_response)

    except (json.JSONDecodeError, Exception) as e:
        error_message = f"Failed to get a valid JSON response from the model or cache. Error: {e}. Raw Response: '{response_text}'"
        print(f"API ERROR: {error_message}")
        return jsonify({"error": error_message}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080, debug=True)
